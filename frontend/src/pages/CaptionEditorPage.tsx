import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useParams, useNavigate } from 'react-router-dom';
import axios from 'axios';
import toast from 'react-hot-toast';
import { 
  Play, 
  Pause, 
  Plus, 
  Edit3, 
  Trash2, 
  Save, 
  X, 
  SkipBack,
  SkipForward,
  Loader2,
  ArrowLeft,
  Undo,
  Redo,
  RotateCcw,
  Move
} from 'lucide-react';

interface CaptionSegment {
  id?: string;
  startTime: number;
  endTime: number;
  text: string;
  confidence?: number;
}

interface Caption {
  id?: string;
  language: string;
  isAutoGenerated: boolean;
  segments: CaptionSegment[];
}

interface MediaInfo {
  id: string;
  title: string;
  duration: number;
  files: Array<{
    id: string;
    downloadUrl: string;
    mimeType: string;
    filename: string;
  }>;
}

interface HistoryState {
  caption: Caption | null;
  timestamp: number;
}

export default function CaptionEditorPage() {
  const { mediaId } = useParams<{ mediaId: string }>();
  const navigate = useNavigate();
  const { getToken } = useAuth();
  
  // Core state
  const [mediaInfo, setMediaInfo] = useState<MediaInfo | null>(null);
  const [captions, setCaptions] = useState<Caption[]>([]);
  const [selectedCaption, setSelectedCaption] = useState<Caption | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [generating, setGenerating] = useState(false);
  
  // Editor state
  const [editingSegment, setEditingSegment] = useState<string | null>(null);
  const [selectedSegments, setSelectedSegments] = useState<Set<number>>(new Set());
  const [isSelecting, setIsSelecting] = useState(false);
  const [selectionStart, setSelectionStart] = useState<{ x: number; y: number } | null>(null);
  const [currentTime, setCurrentTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [zoom, setZoom] = useState(1);
  const [showResetModal, setShowResetModal] = useState(false);
  
  // History for undo/redo
  const [history, setHistory] = useState<HistoryState[]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  
  const audioRef = useRef<HTMLAudioElement>(null);
  const animationFrameRef = useRef<number>();
  const timelineRef = useRef<HTMLDivElement>(null);

  // Load media info and captions
  useEffect(() => {
    if (mediaId) {
      fetchMediaInfo();
      fetchCaptions();
    }
  }, [mediaId]);

  // Audio setup
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const updateTime = () => {
      setCurrentTime(audio.currentTime);
      if (isPlaying) {
        animationFrameRef.current = requestAnimationFrame(updateTime);
      }
    };

    const handlePlay = () => {
      setIsPlaying(true);
      updateTime();
    };

    const handlePause = () => {
      setIsPlaying(false);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };

    const handleTimeUpdate = () => setCurrentTime(audio.currentTime);

    audio.addEventListener('play', handlePlay);
    audio.addEventListener('pause', handlePause);
    audio.addEventListener('ended', handlePause);
    audio.addEventListener('timeupdate', handleTimeUpdate);

    return () => {
      audio.removeEventListener('play', handlePlay);
      audio.removeEventListener('pause', handlePause);
      audio.removeEventListener('ended', handlePause);
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [audioRef.current, isPlaying, mediaInfo?.files?.[0]?.downloadUrl]);

  // Reset editing when caption changes
  useEffect(() => {
    setEditingSegment(null);
    setSelectedSegments(new Set());
  }, [selectedCaption?.id]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
      
      if (e.key === ' ') {
        e.preventDefault();
        togglePlayPause();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        seekTo(currentTime - 5);
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        seekTo(currentTime + 5);
      } else if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
          e.preventDefault();
          redo();
        } else if (e.key === 's') {
          e.preventDefault();
          saveCaptions();
        }
      } else if (e.key === 'Delete' && selectedSegments.size > 0) {
        e.preventDefault();
        deleteSelectedSegments();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [currentTime, selectedSegments, historyIndex]);

  // API functions
  const fetchMediaInfo = async () => {
    try {
      const token = await getToken();
      const response = await axios.get(`/api/media/${mediaId}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      setMediaInfo(response.data.data);
    } catch (error) {
      toast.error('Failed to load media info');
      navigate('/dashboard');
    }
  };

  const fetchCaptions = async () => {
    try {
      const token = await getToken();
      const response = await axios.get(`/api/media/${mediaId}/captions`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      setCaptions(response.data.data);
      if (response.data.data.length > 0) {
        const caption = response.data.data[0];
        setSelectedCaption(caption);
        addToHistory(caption);
      }
    } catch (error) {
      toast.error('Failed to load captions');
    } finally {
      setLoading(false);
    }
  };

  const saveCaptions = async () => {
    if (!selectedCaption) return;
    setSaving(true);
    try {
      const token = await getToken();
      const url = selectedCaption.id 
        ? `/api/media/${mediaId}/captions/${selectedCaption.id}`
        : `/api/media/${mediaId}/captions`;
      
      await axios[selectedCaption.id ? 'put' : 'post'](url, {
        segments: selectedCaption.segments,
        language: selectedCaption.language
      }, {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      toast.success('Captions saved successfully');
      await fetchCaptions();
    } catch (error) {
      toast.error('Failed to save captions');
    } finally {
      setSaving(false);
    }
  };

  const generateCaptions = async () => {
    setGenerating(true);
    try {
      const token = await getToken();
      await axios.post(`/api/media/${mediaId}/captions/generate`, {}, {
        headers: { Authorization: `Bearer ${token}` }
      });
      toast.success('Caption generation started');
      await fetchCaptions();
    } catch (error) {
      toast.error('Failed to generate captions');
    } finally {
      setGenerating(false);
    }
  };

  // History management
  const addToHistory = (caption: Caption | null) => {
    const newState: HistoryState = {
      caption: caption ? JSON.parse(JSON.stringify(caption)) : null,
      timestamp: Date.now()
    };
    
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(newState);
    
    // Limit history to 50 states
    if (newHistory.length > 50) {
      newHistory.shift();
    } else {
      setHistoryIndex(historyIndex + 1);
    }
    
    setHistory(newHistory);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setSelectedCaption(history[newIndex].caption ? JSON.parse(JSON.stringify(history[newIndex].caption)) : null);
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setSelectedCaption(history[newIndex].caption ? JSON.parse(JSON.stringify(history[newIndex].caption)) : null);
    }
  };

  const resetCaptions = () => {
    if (captions.length > 0) {
      const originalCaption = captions[0];
      setSelectedCaption(JSON.parse(JSON.stringify(originalCaption)));
      addToHistory(originalCaption);
      setShowResetModal(false);
      toast.success('Captions reset to saved state');
    }
  };

  // Caption manipulation with history
  const updateCaptionWithHistory = (newCaption: Caption) => {
    setSelectedCaption(newCaption);
    addToHistory(newCaption);
  };

  const addSegment = () => {
    if (!selectedCaption) {
      const newCaption = {
        language: 'en',
        isAutoGenerated: false,
        segments: [{
          startTime: currentTime,
          endTime: currentTime + 3,
          text: 'New caption text',
          confidence: 1.0
        }]
      };
      updateCaptionWithHistory(newCaption);
      return;
    }

    const newSegment: CaptionSegment = {
      startTime: currentTime,
      endTime: currentTime + 3,
      text: 'New caption text',
      confidence: 1.0
    };

    const newCaption = {
      ...selectedCaption,
      segments: [...selectedCaption.segments, newSegment].sort((a, b) => a.startTime - b.startTime)
    };
    
    updateCaptionWithHistory(newCaption);
  };

  const updateSegment = (index: number, updates: Partial<CaptionSegment>) => {
    if (!selectedCaption) return;
    const updatedSegments = [...selectedCaption.segments];
    updatedSegments[index] = { ...updatedSegments[index], ...updates };
    const newCaption = { ...selectedCaption, segments: updatedSegments };
    updateCaptionWithHistory(newCaption);
  };

  const deleteSegment = (index: number) => {
    if (!selectedCaption) return;
    const newCaption = {
      ...selectedCaption,
      segments: selectedCaption.segments.filter((_, i) => i !== index)
    };
    updateCaptionWithHistory(newCaption);
  };

  const deleteSelectedSegments = () => {
    if (!selectedCaption || selectedSegments.size === 0) return;
    
    const newCaption = {
      ...selectedCaption,
      segments: selectedCaption.segments.filter((_, i) => !selectedSegments.has(i))
    };
    
    updateCaptionWithHistory(newCaption);
    setSelectedSegments(new Set());
  };

  const moveSelectedSegments = (deltaTime: number) => {
    if (!selectedCaption || selectedSegments.size === 0) return;
    
    const updatedSegments = [...selectedCaption.segments];
    selectedSegments.forEach(index => {
      const segment = updatedSegments[index];
      const duration = segment.endTime - segment.startTime;
      const newStartTime = Math.max(0, segment.startTime + deltaTime);
      updatedSegments[index] = {
        ...segment,
        startTime: newStartTime,
        endTime: newStartTime + duration
      };
    });
    
    const newCaption = { ...selectedCaption, segments: updatedSegments };
    updateCaptionWithHistory(newCaption);
  };

  // Media controls
  const seekTo = (time: number) => {
    if (audioRef.current && mediaInfo) {
      const clampedTime = Math.max(0, Math.min(time, mediaInfo.duration));
      audioRef.current.currentTime = clampedTime;
      setCurrentTime(clampedTime);
    }
  };

  const togglePlayPause = async () => {
    if (!audioRef.current) return;
    
    try {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        await audioRef.current.play();
      }
    } catch (error) {
      toast.error('Failed to play audio');
    }
  };

  // Selection functions
  const handleSelectionStart = (e: React.MouseEvent) => {
    if (e.target === timelineRef.current) {
      setIsSelecting(true);
      setSelectionStart({ x: e.clientX, y: e.clientY });
      setSelectedSegments(new Set());
    }
  };

  const handleSelectionMove = (e: React.MouseEvent) => {
    if (!isSelecting || !selectionStart || !timelineRef.current) return;
    
    const rect = timelineRef.current.getBoundingClientRect();
    const startX = Math.min(selectionStart.x - rect.left, e.clientX - rect.left);
    const endX = Math.max(selectionStart.x - rect.left, e.clientX - rect.left);
    const startY = Math.min(selectionStart.y - rect.top, e.clientY - rect.top);
    const endY = Math.max(selectionStart.y - rect.top, e.clientY - rect.top);
    
    const newSelection = new Set<number>();
    selectedCaption?.segments.forEach((segment, index) => {
      const pixelsPerSecond = zoom * 20;
      const segmentLeft = segment.startTime * pixelsPerSecond;
      const segmentRight = segment.endTime * pixelsPerSecond;
      const segmentTop = 60 + (index % 5) * 70;
      const segmentBottom = segmentTop + 60;
      
      if (segmentLeft < endX && segmentRight > startX && segmentTop < endY && segmentBottom > startY) {
        newSelection.add(index);
      }
    });
    
    setSelectedSegments(newSelection);
  };

  const handleSelectionEnd = () => {
    setIsSelecting(false);
    setSelectionStart(null);
  };

  // Utility functions
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const formatTimeMs = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = (seconds % 60).toFixed(1);
    return `${mins}:${parseFloat(secs).toFixed(1).padStart(4, '0')}`;
  };

  const getCurrentCaption = () => {
    if (!selectedCaption) return null;
    return selectedCaption.segments.find(
      segment => currentTime >= segment.startTime && currentTime <= segment.endTime
    );
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="bg-gray-800 rounded-xl p-6 flex items-center space-x-3">
          <Loader2 className="w-5 h-5 animate-spin text-purple-400" />
          <span className="text-white">Loading captions...</span>
        </div>
      </div>
    );
  }

  const currentCaption = getCurrentCaption();
  const mediaUrl = mediaInfo?.files?.[0]?.downloadUrl;

  return (
    <div className="bg-gray-900 flex flex-col">
      {/* Header */}
      <div className="bg-gray-800 border-b border-gray-700 p-4">
        <div className="flex flex-col lg:flex-row lg:items-center justify-between space-y-3 lg:space-y-0">
          <div className="flex items-center space-x-4">
            <button 
              onClick={() => navigate('/dashboard')} 
              className="p-2 text-gray-400 hover:text-white transition-colors"
            >
              <ArrowLeft className="w-6 h-6" />
            </button>
            <div>
              <h1 className="text-xl font-semibold text-white">Caption Editor</h1>
              {mediaInfo && (
                <p className="text-sm text-gray-400">{mediaInfo.title}</p>
              )}
            </div>
          </div>
          
          <div className="flex flex-wrap items-center gap-2">
            {/* History controls */}
            <div className="flex items-center border border-gray-600 rounded-lg overflow-hidden">
              <button
                onClick={undo}
                disabled={historyIndex <= 0}
                className="p-2 text-gray-400 hover:text-white disabled:opacity-50 transition-colors"
                title="Undo (Ctrl+Z)"
              >
                <Undo className="w-4 h-4" />
              </button>
              <button
                onClick={redo}
                disabled={historyIndex >= history.length - 1}
                className="p-2 text-gray-400 hover:text-white disabled:opacity-50 transition-colors border-l border-gray-600"
                title="Redo (Ctrl+Y)"
              >
                <Redo className="w-4 h-4" />
              </button>
            </div>

            {/* Caption selector */}
            {captions.length > 1 && (
              <select
                value={selectedCaption?.id || ''}
                onChange={(e) => {
                  const caption = captions.find(c => c.id === e.target.value);
                  if (caption) {
                    setSelectedCaption(caption);
                    addToHistory(caption);
                    setEditingSegment(null);
                    setSelectedSegments(new Set());
                  }
                }}
                className="px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
              >
                {captions.map((caption, index) => (
                  <option key={caption.id || index} value={caption.id || ''}>
                    {caption.language.toUpperCase()} {caption.isAutoGenerated ? '(AI)' : '(Manual)'}
                  </option>
                ))}
              </select>
            )}

            {/* Action buttons */}
            <div className="flex items-center gap-2">
              {captions.length === 0 && (
                <button
                  onClick={generateCaptions}
                  disabled={generating}
                  className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 transition-all flex items-center text-sm"
                >
                  {generating ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : <Plus className="w-4 h-4 mr-2" />}
                  Generate
                </button>
              )}
              
              <button
                onClick={addSegment}
                className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-all flex items-center text-sm"
              >
                <Plus className="w-4 h-4 mr-2" />
                Add
              </button>
              
              <button
                onClick={() => setShowResetModal(true)}
                disabled={!selectedCaption}
                className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 disabled:opacity-50 transition-all flex items-center text-sm"
              >
                <RotateCcw className="w-4 h-4 mr-2" />
                Reset
              </button>
              
              <button
                onClick={saveCaptions}
                disabled={saving || !selectedCaption}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-all flex items-center text-sm"
              >
                {saving ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : <Save className="w-4 h-4 mr-2" />}
                Save
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Media Player */}
      {mediaUrl && (
        <div className="bg-gray-800 border-b border-gray-700 p-4">
          <div>
            <audio ref={audioRef} src={mediaUrl} preload="metadata" />
            
            <div className="flex flex-col sm:flex-row items-center justify-between space-y-3 sm:space-y-0">
              <div className="flex items-center space-x-4">
                <button
                  onClick={togglePlayPause}
                  className="p-3 bg-purple-600 text-white rounded-full hover:bg-purple-700 transition-all"
                >
                  {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6" />}
                </button>
                
                <div className="text-sm text-gray-300">
                  {formatTime(currentTime)} / {formatTime(mediaInfo?.duration || 0)}
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => seekTo(currentTime - 5)}
                  className="p-2 text-gray-400 hover:text-white transition-colors"
                >
                  <SkipBack className="w-5 h-5" />
                </button>
                <button
                  onClick={() => seekTo(currentTime + 5)}
                  className="p-2 text-gray-400 hover:text-white transition-colors"
                >
                  <SkipForward className="w-5 h-5" />
                </button>
              </div>
            </div>
            
            {/* Timeline Scrubber */}
            <div className="mt-4">
              <div className="relative w-full h-2 bg-gray-700 rounded-full">
                <div
                  className="absolute top-0 left-0 h-full bg-purple-600 rounded-full transition-all duration-75"
                  style={{ width: `${mediaInfo?.duration ? (currentTime / mediaInfo.duration) * 100 : 0}%` }}
                />
                <input
                  type="range"
                  min="0"
                  max={mediaInfo?.duration || 0}
                  value={currentTime}
                  onChange={(e) => seekTo(parseFloat(e.target.value))}
                  className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                />
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Current Caption Preview */}
      <div className="bg-purple-900/20 border-b border-purple-500/30 p-4">
        <div className="flex items-center justify-between">
          <div className="flex-1">
            <div className="text-xs text-purple-400 mb-1">Now Playing</div>
            <div className="text-white font-medium">{currentCaption?.text || '-'}</div>
          </div>
          <div className="text-xs text-purple-300 ml-4">
            {formatTimeMs(currentCaption?.startTime || 0)} - {formatTimeMs(currentCaption?.endTime || 0)}
          </div>
        </div>
      </div>

      {/* Mass Selection Controls */}
      {selectedSegments.size > 0 && (
        <div className="bg-yellow-900/20 border-b border-yellow-500/30 p-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <span className="text-yellow-300 text-sm">
                {selectedSegments.size} segments selected
              </span>
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => moveSelectedSegments(-1)}
                  className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 transition-colors"
                >
                  ‚Üê 1s
                </button>
                <button
                  onClick={() => moveSelectedSegments(1)}
                  className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 transition-colors"
                >
                  1s ‚Üí
                </button>
                <button
                  onClick={deleteSelectedSegments}
                  className="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700 transition-colors"
                >
                  Delete
                </button>
              </div>
            </div>
            <button
              onClick={() => setSelectedSegments(new Set())}
              className="text-gray-400 hover:text-white transition-colors"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}

      {/* Timeline Editor */}
      <div className="flex-1 overflow-auto min-h-0">
        {selectedCaption ? (
          <TimelineView
            key={selectedCaption.id || 'new'}
            caption={selectedCaption}
            currentTime={currentTime}
            duration={mediaInfo?.duration || 0}
            zoom={zoom}
            setZoom={setZoom}
            editingSegment={editingSegment}
            setEditingSegment={setEditingSegment}
            selectedSegments={selectedSegments}
            setSelectedSegments={setSelectedSegments}
            isSelecting={isSelecting}
            onSelectionStart={handleSelectionStart}
            onSelectionMove={handleSelectionMove}
            onSelectionEnd={handleSelectionEnd}
            updateSegment={updateSegment}
            deleteSegment={deleteSegment}
            seekTo={seekTo}
            formatTimeMs={formatTimeMs}
            timelineRef={timelineRef}
          />
        ) : (
          <EmptyState onGenerate={generateCaptions} generating={generating} />
        )}
      </div>

      {/* Reset Confirmation Modal */}
      {showResetModal && (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
          <div className="bg-gray-800 rounded-xl p-6 max-w-md mx-4">
            <h3 className="text-lg font-semibold text-white mb-4">Reset Captions?</h3>
            <p className="text-gray-400 mb-6">
              This will reset all changes back to the last saved state. This action cannot be undone.
            </p>
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => setShowResetModal(false)}
                className="px-4 py-2 text-gray-400 hover:text-white transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={resetCaptions}
                className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
              >
                Reset
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Timeline View Component with mass selection
function TimelineView({ 
  caption, currentTime, duration, zoom, setZoom, editingSegment, 
  setEditingSegment, selectedSegments, setSelectedSegments, isSelecting,
  onSelectionStart, onSelectionMove, onSelectionEnd, updateSegment, 
  deleteSegment, seekTo, formatTimeMs, timelineRef 
}: any) {
  const [draggedSegment, setDraggedSegment] = useState<number | null>(null);
  const [dragMode, setDragMode] = useState<'move' | 'resize-start' | 'resize-end' | null>(null);
  const [isMobile, setIsMobile] = useState(window.innerWidth < 768);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const pixelsPerSecond = zoom * (isMobile ? 15 : 20);
  const timelineWidth = Math.max(duration * pixelsPerSecond, isMobile ? 400 : 800);

  const handleMouseDown = useCallback((e: React.MouseEvent, segmentIndex: number, mode: 'move' | 'resize-start' | 'resize-end') => {
    e.preventDefault();
    e.stopPropagation();
    setDraggedSegment(segmentIndex);
    setDragMode(mode);
  }, []);

  const handleSegmentClick = (e: React.MouseEvent, index: number) => {
    e.stopPropagation();
    if (e.ctrlKey || e.metaKey) {
      // Multi-select
      const newSelection = new Set(selectedSegments);
      if (newSelection.has(index)) {
        newSelection.delete(index);
      } else {
        newSelection.add(index);
      }
      setSelectedSegments(newSelection);
    } else {
      // Single select or edit
      if (selectedSegments.size <= 1) {
        setEditingSegment(`${index}`);
      }
      setSelectedSegments(new Set([index]));
    }
  };

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (isSelecting) {
      onSelectionMove({ clientX: e.clientX, clientY: e.clientY } as React.MouseEvent);
      return;
    }

    if (draggedSegment === null || !dragMode || !timelineRef.current) return;

    const rect = timelineRef.current.getBoundingClientRect();
    const time = (e.clientX - rect.left) / pixelsPerSecond;
    const segment = caption.segments[draggedSegment];
    
    if (dragMode === 'move') {
      const segmentDuration = segment.endTime - segment.startTime;
      updateSegment(draggedSegment, {
        startTime: Math.max(0, time - segmentDuration / 2),
        endTime: Math.max(segmentDuration, time + segmentDuration / 2)
      });
    } else if (dragMode === 'resize-start') {
      updateSegment(draggedSegment, {
        startTime: Math.max(0, Math.min(time, segment.endTime - 0.1))
      });
    } else if (dragMode === 'resize-end') {
      updateSegment(draggedSegment, {
        endTime: Math.max(segment.startTime + 0.1, time)
      });
    }
  }, [draggedSegment, dragMode, pixelsPerSecond, caption.segments, updateSegment, isSelecting, onSelectionMove]);

  const handleMouseUp = useCallback(() => {
    if (isSelecting) {
      onSelectionEnd();
      return;
    }
    setDraggedSegment(null);
    setDragMode(null);
  }, [isSelecting, onSelectionEnd]);

  useEffect(() => {
    if (draggedSegment !== null || isSelecting) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [draggedSegment, isSelecting, handleMouseMove, handleMouseUp]);

  return (
    <div className="h-full flex flex-col">
      {/* Timeline Controls */}
      <div className="bg-gray-800 border-b border-gray-700 p-4">
        <div className="flex flex-col sm:flex-row sm:items-center justify-between space-y-3 sm:space-y-0">
          <div className="flex items-center space-x-4">
            <span className="text-sm text-gray-400">Zoom:</span>
            <input
              type="range"
              min="0.5"
              max="5"
              step="0.1"
              value={zoom}
              onChange={(e) => setZoom(parseFloat(e.target.value))}
              className="w-24"
            />
            <span className="text-sm text-white">{zoom.toFixed(1)}x</span>
          </div>
          
          <div className="text-sm text-gray-400">
            {caption.segments.length} segments | {formatTimeMs(currentTime)}
          </div>
        </div>
      </div>

      {/* Timeline */}
      <div className="flex-1 overflow-auto min-h-0">
        <div 
          ref={timelineRef}
          className="relative bg-gray-900 h-full min-h-full select-none"
          style={{ width: timelineWidth, minHeight: '500px' }}
          onMouseDown={onSelectionStart}
          onClick={(e) => {
            if (e.target === timelineRef.current) {
              const rect = e.currentTarget.getBoundingClientRect();
              const time = (e.clientX - rect.left) / pixelsPerSecond;
              seekTo(time);
            }
          }}
        >
          {/* Time Ruler */}
          <div className="sticky top-0 bg-gray-800 border-b border-gray-700 h-12 flex items-center z-10">
            {Array.from({ length: Math.ceil(duration / (isMobile ? 20 : 10)) + 1 }, (_, i) => i * (isMobile ? 20 : 10)).map(time => (
              <div
                key={time}
                className="absolute text-xs text-gray-400"
                style={{ left: time * pixelsPerSecond }}
              >
                {formatTimeMs(time)}
              </div>
            ))}
          </div>

          {/* Playhead */}
          <div
            className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-20 transition-all duration-75"
            style={{ left: currentTime * pixelsPerSecond }}
          >
            <div className="absolute top-0 w-3 h-3 bg-red-500 rounded-full transform -translate-x-1/2" />
          </div>

          {/* Caption Segments */}
          <div className="pt-16 pb-8 min-h-full h-full relative">
            {caption.segments.map((segment: CaptionSegment, index: number) => (
              <div
                key={index}
                className={`absolute h-16 border rounded cursor-pointer group transition-all ${
                  selectedSegments.has(index)
                    ? 'bg-yellow-500/90 border-yellow-400 ring-2 ring-yellow-400'
                    : 'bg-purple-600/80 border-purple-500 hover:bg-purple-600'
                } ${editingSegment === `${index}` ? 'ring-2 ring-blue-400' : ''}`}
                style={{
                  left: segment.startTime * pixelsPerSecond,
                  width: Math.max((segment.endTime - segment.startTime) * pixelsPerSecond, isMobile ? 40 : 60),
                  top: 60 + (index % (isMobile ? 3 : 5)) * (isMobile ? 60 : 70)
                }}
                onClick={(e) => handleSegmentClick(e, index)}
              >
                {/* Resize handles - desktop only */}
                {!isMobile && (
                  <>
                    <div
                      className="absolute left-0 top-0 bottom-0 w-2 bg-purple-400 cursor-w-resize opacity-0 group-hover:opacity-100 transition-opacity"
                      onMouseDown={(e) => handleMouseDown(e, index, 'resize-start')}
                    />
                    <div
                      className="absolute right-0 top-0 bottom-0 w-2 bg-purple-400 cursor-e-resize opacity-0 group-hover:opacity-100 transition-opacity"
                      onMouseDown={(e) => handleMouseDown(e, index, 'resize-end')}
                    />
                  </>
                )}
                
                <div 
                  className="px-2 py-1 h-full flex flex-col justify-center text-white text-xs truncate"
                  onMouseDown={(e) => !isMobile && handleMouseDown(e, index, 'move')}
                >
                  <div className="font-medium truncate">{segment.text}</div>
                  <div className="text-purple-200 text-[10px]">
                    {formatTimeMs(segment.startTime)} - {formatTimeMs(segment.endTime)}
                  </div>
                </div>

                <button
                  className="absolute -top-2 -right-2 w-6 h-6 bg-red-600 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center hover:bg-red-700"
                  onClick={(e) => {
                    e.stopPropagation();
                    deleteSegment(index);
                  }}
                >
                  <X className="w-3 h-3" />
                </button>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Editing Panel */}
      {editingSegment !== null && (
        <SegmentEditPanel
          segment={caption.segments[parseInt(editingSegment)]}
          onSave={(updates) => {
            updateSegment(parseInt(editingSegment), updates);
            setEditingSegment(null);
          }}
          onCancel={() => setEditingSegment(null)}
          formatTimeMs={formatTimeMs}
        />
      )}
    </div>
  );
}

// Segment Edit Panel
function SegmentEditPanel({ segment, onSave, onCancel, formatTimeMs }: any) {
  const [editText, setEditText] = useState(segment.text);
  const [editStartTime, setEditStartTime] = useState(segment.startTime);
  const [editEndTime, setEditEndTime] = useState(segment.endTime);

  useEffect(() => {
    setEditText(segment.text);
    setEditStartTime(segment.startTime);
    setEditEndTime(segment.endTime);
  }, [segment]);

  return (
    <div className="bg-gray-800 border-t border-gray-700 p-4">
      <div className="max-w-4xl mx-auto">
        <h3 className="text-lg font-semibold text-white mb-4">Edit Caption Segment</h3>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">Start Time</label>
            <input
              type="number"
              step="0.1"
              value={editStartTime}
              onChange={(e) => setEditStartTime(parseFloat(e.target.value))}
              className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">End Time</label>
            <input
              type="number"
              step="0.1"
              value={editEndTime}
              onChange={(e) => setEditEndTime(parseFloat(e.target.value))}
              className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-1">Duration</label>
            <div className="px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-400 text-sm">
              {formatTimeMs(editEndTime - editStartTime)}
            </div>
          </div>
        </div>
        
        <div className="mt-4">
          <label className="block text-sm font-medium text-gray-300 mb-1">Caption Text</label>
          <textarea
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            rows={3}
            className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
            placeholder="Enter caption text..."
          />
        </div>
        
        <div className="flex justify-end space-x-3 mt-4">
          <button
            onClick={onCancel}
            className="px-4 py-2 text-gray-400 hover:text-white transition-colors text-sm"
          >
            Cancel
          </button>
          <button
            onClick={() => onSave({ 
              text: editText, 
              startTime: editStartTime, 
              endTime: editEndTime 
            })}
            className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-all text-sm"
          >
            Save Changes
          </button>
        </div>
      </div>
    </div>
  );
}

// Empty State Component
function EmptyState({ onGenerate, generating }: { onGenerate: () => void; generating: boolean }) {
  return (
    <div className="flex items-center justify-center h-full p-4">
      <div className="text-center">
        <div className="text-6xl mb-4">üé¨</div>
        <h3 className="text-xl font-semibold text-white mb-2">No Captions Yet</h3>
        <p className="text-gray-400 mb-4">
          Generate AI captions or create them manually
        </p>
        <button
          onClick={onGenerate}
          disabled={generating}
          className="px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50 transition-all"
        >
          {generating ? 'Generating...' : 'Generate Captions'}
        </button>
      </div>
    </div>
  );
} 